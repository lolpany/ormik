### мутации

* каждая таблица имеет только один bean содержащий все поля таблицы и все getter'ы/setter'ы
* нельзя делать update/insert таблиц напрямую, можно только создавать bean или сеттить значение в bean'е, а потом уже писать bean в таблицу
    * можно делать batch апдейты
    * апдейты предполагают lock строк в таблицах, так что случаи массовых апдейтов в коде минимальны, но и для них можно придумать какой нибудь струкурный (чтобы не искать чисто текстово по названию поля) способ обозначать таблицы/поля
* в рамках отдельных сервисов/роботов/пакетов для каждой таблицы используется отдельный интерфейс с сеттерами и геттерами нужными в это сервисе/роботе/пакете
* если нужно органичить набор читаемых из бд полей (по соображениям производительности), то в сервисах/роботах создается bean наследник bean'а содержащего все поля таблицы, он реализует интерфейсы используемые в сервисах/роботах/пакетах (getter'ы/setter'ы уже есть в родителе), его конструктор инициализирует только поля необходимые в этом сервисе/роботе
* для четния из таблиц не обязательно использовать bean'ы
    * отчеты могут использовать join'ы и выбирать большое число строк



плюсы:
* для поля таблицы по alt+f7 на поле бина и выборе фильтра "show write access" (или на сеттере в интерфейсе) можно найти все места (для интерфейса все места в сервисе/роботе) в коде (java, еще есть pl/sql и foxpro) где это поле меняется
* минимум boilerplate-кода (нет кучи bean'ов, getters/setters)
* возможность ограничить набор полей для производительности
* возможность возврата к Hibernate


























### id-enums

* использовать IdEnum'ы везде (в том числе и при формировании sql запроса) чтобы легко восстановить бизнес логику по коду
* выносить логику аспекта в отдельный пакет 
    * b_smres и связанные поля, логика переходов, журналирование
    * b_stat и связанные поля, логика переходов, журналирование
    * ord_m.b_inv, inv_ord, ...
    * conf
    * punishment, penalty
    * ...



плюсы
* полезно для решения определенного рода задач 




























### тестирование

* на каждый сервис/робот писать регрисионный интеграционный тест (пример, Go-классы)
* тестировщики тестируют новые фичи



плюсы
* при затрагивании старого кода очень дешевая по времени и очень качественная проверка
